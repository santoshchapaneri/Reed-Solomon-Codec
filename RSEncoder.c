#include <stdio.h>
#include <stdlib.h>
#include "field.h"
#include "functions.h"

unsigned zechspow[256];	/*Add-one table*/
GFPowRep *GenPoly;

void blockEncode(GFPowRep *block, GFPowRep *Register);

/*	Function:	RSEncoder()
	Inputs:
	Outputs:
	Algorithm:	*/

void RSEncoder(char *fin, char *fout)
{
	int i, j, breakflag=0;
	unsigned char input;
	GFPowRep *block, *paritycode;

	int total =0,count = 0;
	FILE *finput, *foutput;

	// Open the files
	if((finput = fopen(fin,"rb")) == NULL)
	{
		printf("\nInput file not found!\n");
		return;
	}
	
	if((foutput = fopen(fout,"wb")) == NULL)
	{
		printf("\nCannot create output file!\n");
		return;
	}

	// Allocate memory
	GenPoly=(GFPowRep*)calloc(PAR,sizeof(GFPowRep));
	block = (GFPowRep*)malloc(MSG*sizeof(GFPowRep));
	paritycode = (GFPowRep*)calloc(PAR,sizeof(GFPowRep));

	// Create the Generator Polynomial
	GeneratorCreator(GenPoly);

	// Read the blocks and encode
	while(!breakflag)
	{
		for(i=0;i<MSG;i++)
		{
			fscanf(finput,"%c",&input);
			if(feof(finput))
			{
				for(j=i;j<MSG;j++)
				{
					block[j] = (GFPowRep)46;	// '.' character
				}
				breakflag = 1;
				break;
			}				
			else
			{
				fprintf(foutput,"%c",input);
				input %= FIELD;
				block[i] = (GFPowRep)(input);
			}
		}

		// Find the parity bits for this block
		blockEncode(block,paritycode);
		
		// Write the parity bits into the file
		for(i=0;i<PAR;i++)
			fprintf(foutput,"%c",(unsigned char)paritycode[i]);
	}

	// Close the files
	fclose(finput);
	fclose(foutput);
	printf("Encoded file is \"%s\"\n",fout);
}

void blockEncode(GFPowRep *block, GFPowRep *Register)
{
	int i, j;
	GFPowRep Gate;		// Gate = I + Reg[n-1]

	// Initializing all the registers to "zeros"
	for(j=0;j<PAR;j++)
	{
		Register[j] = FIELD-1;
	}

	// Start the LFSR encoding
	for(i=MSG-1;i>=0;i--)
	{
		Gate = GFAddition(Register[PAR-1],block[i]);

		for(j=PAR-1;j>=1;j--)
		{
			Register[j] = GFMultiplication(Gate,GenPoly[j]);
			Register[j] = GFAddition(Register[j],Register[j-1]);
		}
		Register[0] = GFMultiplication(Gate,GenPoly[0]);
	}

} // End blockEncode()


/*	Function:	GeneratorCreator
	Inputs:		Parity, GenPoly, Field
	Outputs:	None, stored in pointer GenPoly
	Algorithm:	This function generates the generator polynomial with the help of its
	2t successive roots as the inputs (2t = Number of parity symbols in the codeword).
	Example:    For GF(8) with parity = 4, g(X) = X^4 + alpha^3 X^3 + X^2 + alpha X + alpha^3,
	            the output of this code will be 
				"Gen[0] = 3, Gen[1] = 1, Gen[2] = 0, Gen[3] = 3"
				Always, highest degree coeff is alpha^0 and therefore not stored. Also 
				note, only powers of alpha are stored in GenPoly
*/
void GeneratorCreator(GFPowRep *GenPoly)
{
	GFPowRep *TempPoly, temp=2;
	unsigned short i,j;
	
	TempPoly=(unsigned short*)malloc(PAR*(sizeof(GFPowRep)));
	/*Note: The highest degree coefficient of the Generator Polynomial
	will always be alpha^0. Therefore it is not considered and not stored.
	The size of the generator polynomial (array) is 'PARITY' and not
	'Parity -1'.*/

	GenPoly[0]=(GFPowRep)1;

	for(j=1;j<PAR;j++)
	{
		for(i=0;i<=j;i++)
		{
			TempPoly[i] = GenPoly[i];
			GenPoly[i] = GFMultiplication(GenPoly[i],temp);
		}

		for(i=0;i<j;i++)
			GenPoly[i+1] = GFAddition(GenPoly[i+1],TempPoly[i]);
		temp = (temp++)%(FIELD - 1);/*Modulus is taken as a precautionary step,
									incase the degree of the generator polynomial
									is set higher than FIELD - 1*/
	}
/*	for(i=0;i<PAR;i++)
		printf("GEN[%d] = %d\n",i,GenPoly[i]);
	printf("\n");
*/	
	free(TempPoly);
}

void ZechsLogarithms()
{
	unsigned alphapow[256];
	unsigned poweroftwo[31]; /*powers of 2*/
	unsigned M = POWER, maxGFsize = FIELD;
	unsigned reduce;
	unsigned temp;
	unsigned n;

	switch(POWER)
	{
	case 3:
		reduce = 3;//g(X) = X^3 + X + 1
		break;
	case 4:
		reduce = 3;//g(X) = X^4+X+1
		break;
	case 8:
		reduce = 29;//g(X) = X^8 + X^4 + X^3 + X^2 + 1
		break;
	default:
		reduce = 29;//M=8
		break;
	};
	
/*reduce is calculated from the primitive polynomial as follows:
subtract the higest order term (X^M)
and evaluate remaining polynomial at X=2
e.g., GF(2^5) generated by g(X)=1 + X^2 + X^5
get rid of X^5 term and evaluate 1 + X^2 at X=2 which gives reduce=5*/
	
	poweroftwo[0]=1;
	for(n=1;n<=M;n++)
		poweroftwo[n]=2*poweroftwo[n-1];
	
	alphapow[0] = 1;	/*alpha^0 = 1*/
	for(n=1;n<poweroftwo[M]-1;n++)
	{
		temp = alphapow[n-1];
		temp = (temp<<1);				/*multiply by alpha*/
		if(temp & poweroftwo[M])		/*contains alpha^M term*/
			alphapow[n] = (temp & ~poweroftwo[M])^reduce; //bitwise operators 'and', 'ones complement' and 'ex-or'
		else
			alphapow[n] = temp;			/*if no alpha^M term, store as it is*/
	}
	alphapow[n] = FIELD-1;

	//Compute Zechs powers
	zechspow[0] = FIELD-1;
	for(n=1;n<poweroftwo[M] - 1;n++)
		zechspow[n] = alphapow[n]^1;
	zechspow[n] = 0;	

	//printf("Zechspow[0] = %d\n",zechspow[0]);
	for(n=1;n<poweroftwo[M] - 1;n++)
	{
		for(temp=0;temp<poweroftwo[M];temp++)
		{
			if(zechspow[n] == alphapow[temp])
			{
				zechspow[n] = temp;
				break;
			}
		}
//		printf("Zechspow[%d] = %d\n",n,zechspow[n]);
	}
//	printf("Zechspow[%d] = %d\n",n,zechspow[n]);
}

/*	Function:	EXP_Multiplication
	Inputs:		exponential values of two Galois Field elements
	Outputs:	exponential value of the product of the two GF elements
	Algorithm:	If both inputs are Non Zero values(eg. alpha^0, alpha^1 etc
				then their product is given by modular sumation of the exponential
				inputs over 'FIELD - 1'. However if either of the inputs is 'ZERO'
				then the result is ZERO.
				NOTE: The 'ZERO' term is represented by the value 'FIELD' here*/

GFPowRep GFMultiplication(GFPowRep elem1, GFPowRep elem2)
{	
	if(elem1==FIELD-1 || elem2==FIELD-1)
		return FIELD-1;
	
	return((elem1+elem2)%(FIELD-1));
}

/*	Function:	EXP_Additon
	Inputs:		exponential values of two Galois Field elements
	Outputs:	exponential value of the summation of the two GF elements
	Algorithm:	The function uses ZechsLogarithms to calculate the
				summation of two Galois Field elements*/
GFPowRep GFAddition(GFPowRep elem1, GFPowRep elem2)
{
	if(elem1 == elem2)		    return FIELD-1;
	else if(elem1 == FIELD-1)	return elem2;
	else if(elem2 == FIELD-1)	return elem1;
	else if(elem1 > elem2)
	{
		/*To calculate summation to GF(8) elements consider the follwing example:
		a^5 + a^3 = a^3(a^2 - 1)
		now form zechslogarithms we get (a^2 - 1) = a^6
		Therefore: a^5 + a^3 = (a^3)(a^6) = (a^9)%(FIELD-1) = a^2*/
		elem1 = elem1 - elem2;
		elem1 = zechspow[elem1];
		return((elem1+elem2)%(FIELD-1));
	}
	else
	{
		elem2 = elem2 - elem1;
		elem2 = zechspow[elem2];
		return((elem1+elem2)%(FIELD-1));
	}
}

GFPowRep GFExponentiation(GFPowRep elem1, int power)
{
	int value;

	if(elem1 == FIELD-1)
		return elem1;

	if(power == 0)
		return (GFPowRep)0;

	value = ((int)elem1) * power;
	value %= (int)(FIELD-1);
	
	if(value<0)
	{
		value += (int)FIELD-1;
	}	
	
	return (GFPowRep)value;
}
